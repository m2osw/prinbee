# Sample of Snap! Database configuration file
#
# The file is a basic list of variable name = value
# Comments start with a # character, must be the first character after spaces
# Empty lines are ignored


# log_config=<path to log settings>
#
# This variable defines the settings that the snaplogger library reads
# to handle logging of the Prinbee daemon. By default, the logger checks
# many files automatically. You can check the list using the following
# command line option:
#
#    prinbee-daemon --logger-configuration-filenames
#
# Default: /etc/prinbee/logger/prinbee-daemon.conf
#log_config=/etc/prinbee/logger/prinbee-daemon.conf


# communicator_listen=cd:///<ip>:<port> | cd:///<path>
#
# The IP address and port used to connect to the communicator daemon using
# a TCP connection or the Unix socket path.
#
# The prinbee-daemon uses this connection to communicate with several other
# services such as the communicator daemon itself, the cluck service, the
# fluid-settings service, etc.
#
# However, to send database commands, a binary connection is used. This
# is shared with a message through the communicator daemon to the client
# which can then connect to the binary port and start communicating with
# the prinbee database directly.
#
# Default: cd:///run/communicator/communicatord.sock
#communicator_listen=cd:///run/communicator/communicatord.sock


# direct_listen=<IP:port>
#
# The IP address and port this daemon uses to listen for direct binary
# connections. Direct connections come directly from clients to a daemon
# without going through a proxy.
#
# Default: :4042
#direct_listen=:4042


# proxy_listen=<IP:port>
#
# The IP address and port this daemon uses to listen for connections from
# Prinbee proxies. In most cases, clients connect to a proxy and send
# database commands through that proxy. This makes it a lot easier
# for the client which then does not need to know to which daemon to send
# messages to for the network transfer to be as effective as possible.
#
# Default: :4010
#proxy_listen=:4010


# node_listen=<IP:port>
#
# The IP address and port this daemon uses to listen for other daemons.
#
# A Prinbee daemon decides to connect to another when its IP address is
# smaller. Since the connections are using TCP, it goes both ways and
# thus we do not need to connect in both directions.
#
# All the nodes always try to connect to all the other nodes. The one
# main exception is when you have nodes in different data centers. In
# that case, in order to control the data transfers better, you generally
# only have one connection between two data centers.
#
# Default: :4011
#node_listen=:4011


# cluster_name=<name-of-cluster>
#
# Prinbee works with multiple nodes. All the nodes in a cluster participate
# in that cluster's data distribution. Two prinbee daemons running with
# a different cluster name are considered two separate instances and the
# data is not shared between them.
#
# Default: prinbee
#cluster_name=prinbee


# node_name=<name-of-node>
#
# Prinbee works with multiple nodes. Each node must have a different name.
# This variable is used to name the node. By default, it uses the output
# of the `hostname` command assuming the characters are compatible. If not
# compatible, then a fatal error occurs and you need to specify this
# parameter or change your host name.
#
# Default: <hostname>
#node_name=<hostname>


# prinbee_path=<path where contexts are created>
#
# This parameter holds the path to the location where Prinbee creates
# contexts. This is usually set to a folder under /var/lib/...
#
# Moving an existing context should work just fine as long as you update
# the configuration file accordingly (and stop the daemon before doing
# the move and restart it once the move is done).
#
# Default: /var/lib/prinbee
#prinbee_path=/var/lib/prinbee


# number_of_workers=<count>
#
# This parameter defines the number of workers you want to have running
# on this node.
#
# Prinbee forces a minimum of 2 workers, even if you have a single CPU.
# It also makes sure the number if no more than 2 x the number of CPUs.
# By default, it will create 1 worker per CPU with a minimum of 2.
#
# The Prinbee system runs using a batch mechanism. Each piece of work
# that needs to be done is defined in a batch object. Some jobs may take
# longer than others (seconds, minutes, hours...) To smooth out
# the work, batches have different levels of importance. Very long jobs
# are broken up in small batches so that way things move forward
# in parallel. Also to not lose work, all the batches are saved in a
# journal on disk. That way we make sure that all jobs run to completion
# even if the database is turned off.
#
# Note: when a process gains an exclusive lock (i.e. read & write permissions)
#       it will not release that lock until it is done, so that part of the
#       processing runs in one go whatever amount of time is required to
#       complete the task.
#
# Default: <number-of-cpus>
#workers=...


# vim: wrap
